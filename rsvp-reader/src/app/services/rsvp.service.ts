import { Injectable, OnDestroy, Inject, forwardRef, Injector } from '@angular/core';nimport { BehaviorSubject, combineLatest, map, interval, EMPTY, Subject } from 'rxjs';nimport { switchMap, takeWhile, tap, takeUntil, filter } from 'rxjs/operators';nimport { RSVPState } from '../models/rsvp-state.interface';nimport { TextProcessor } from '../utils/text-processor';nimport { CONSTANTS } from '../utils/constants';nimport { NotificationService } from './notification.service';nnexport type TextSource = 'manual' | 'epub' | 'library' | null;nn@Injectable({n  providedIn: 'root'n})nexport class RSVPService implements OnDestroy {n  private destroy$ = new Subject<void>();nn  // Private subjectsn  private wordsSubject = new BehaviorSubject<string[]>([]);n  private currentIndexSubject = new BehaviorSubject<number>(0);n  private isPlayingSubject = new BehaviorSubject<boolean>(false);n  private wpmSubject = new BehaviorSubject<number>(CONSTANTS.DEFAULT_WPM);n  private errorSubject = new BehaviorSubject<string | null>(null);n  private textSourceSubject = new BehaviorSubject<TextSource>(null);n  n  // Library integrationn  private currentBookIdSubject = new BehaviorSubject<string | null>(null);n  private sessionStartTime: Date | null = null;n  private lastProgressSave = 0;n  private readonly PROGRESS_SAVE_INTERVAL = 10; // Save progress every 10 wordsnn  // Public observablesn  public words$ = this.wordsSubject.asObservable();n  public currentIndex$ = this.currentIndexSubject.asObservable();n  public isPlaying$ = this.isPlayingSubject.asObservable();n  public wpm$ = this.wpmSubject.asObservable();n  public error$ = this.errorSubject.asObservable();n  public textSource$ = this.textSourceSubject.asObservable();n  public currentBookId$ = this.currentBookIdSubject.asObservable();nn  // Computed observablesn  public currentWord$ = combineLatest([this.words$, this.currentIndex$]).pipe(n    map(([words, index]) => words[index] || '')n  );nn  public rsvpState$ = combineLatest([n    this.words$,n    this.currentIndex$,n    this.isPlaying$,n    this.wpm$n  ]).pipe(n    map(([words, currentIndex, isPlaying, wpm]) => {n      const totalWords = words.length;n      const progress = totalWords > 0 ? (currentIndex / totalWords) * 100 : 0;n      const currentWord = words[currentIndex] || '';n      const timeRemaining = totalWords > 0 ? Math.round((totalWords - currentIndex) * (60 / wpm)) : 0;n      n      return {n        words,n        currentIndex,n        isPlaying,n        wpm,n        currentWord,n        progress,n        totalWords,n        timeRemainingn      } as RSVPState;n    })n  );nn  constructor(n    private notificationService: NotificationService,n    private injector: Injectorn  ) {n    this.initializeAutoPlay();n  }nn  ngOnDestroy(): void {n    this.destroy$.next();n    this.destroy$.complete();n  }nn  private initializeAutoPlay(): void {n    combineLatest([n      this.isPlaying$,n      this.currentIndex$,n      this.words$,n      this.wpm$n    ]).pipe(n      takeUntil(this.destroy$),n      switchMap(([isPlaying, currentIndex, words, wpm]) => {n        if (isPlaying && currentIndex < words.length) {n          return interval(TextProcessor.calculateInterval(wpm)).pipe(n            takeUntil(this.isPlaying$.pipe(filter(playing => !playing))),n            tap(() => {n              const nextIndex = this.currentIndexSubject.value + 1;n              if (nextIndex >= words.length) {n                this.pause(); // Auto-pause at endn              } else {n                this.currentIndexSubject.next(nextIndex);n              }n            })n          );n        }n        return EMPTY;n      })n    ).subscribe();n  }nn  setText(text: string, source: TextSource = 'manual'): void {n    try {n      const words = TextProcessor.processText(text);n      this.wordsSubject.next(words);n      this.currentIndexSubject.next(0);n      this.textSourceSubject.next(source);n      this.clearError();n      n      if (source === 'library') {n        this.startReadingSession();n      }n    } catch (error) {n      this.handleError('Metin işlenirken hata oluştu', error);n    }n  }nn  clearText(): void {n    this.wordsSubject.next([]);n    this.currentIndexSubject.next(0);n    this.isPlayingSubject.next(false);n    this.textSourceSubject.next(null);n    this.currentBookIdSubject.next(null);n    this.clearError();n  }nn  get currentTextSource(): TextSource {n    return this.textSourceSubject.value;n  }nn  play(): void {n    if (this.wordsSubject.value.length === 0) {n      this.notificationService.showWarning('Okunacak metin bulunamadı');n      return;n    }nn    if (this.currentIndexSubject.value >= this.wordsSubject.value.length) {n      this.restart();n    }nn    this.isPlayingSubject.next(true);n  }nn  pause(): void {n    this.isPlayingSubject.next(false);n  }nn  stop(): void {n    this.isPlayingSubject.next(false);n    this.currentIndexSubject.next(0);n  }nn  restart(): void {n    this.currentIndexSubject.next(0);n    this.isPlayingSubject.next(true);n  }nn  next(): void {n    const currentIndex = this.currentIndexSubject.value;n    const words = this.wordsSubject.value;n    n    if (currentIndex < words.length - 1) {n      this.currentIndexSubject.next(currentIndex + 1);n    }n  }nn  previous(): void {n    const currentIndex = this.currentIndexSubject.value;n    n    if (currentIndex > 0) {n      this.currentIndexSubject.next(currentIndex - 1);n    }n  }nn  jumpToIndex(index: number): void {n    const words = this.wordsSubject.value;n    if (index >= 0 && index < words.length) {n      this.currentIndexSubject.next(index);n    }n  }nn  jumpToPercentage(percentage: number): void {n    const words = this.wordsSubject.value;n    const index = Math.floor((percentage / 100) * words.length);n    this.jumpToIndex(index);n  }nn  setWpm(wpm: number): void {n    if (wpm >= CONSTANTS.MIN_WPM && wpm <= CONSTANTS.MAX_WPM) {n      this.wpmSubject.next(wpm);n    } else {n      this.handleError('Geçersiz WPM değeri', null);n    }n  }nn  private handleError(message: string, error: any): void {n    this.errorSubject.next(message);n    this.notificationService.showError(message);n    console.error('RSVP Service Error:', error);n  }nn  clearError(): void {n    this.errorSubject.next(null);n  }nn  getCurrentState(): RSVPState {n    const words = this.wordsSubject.value;n    const currentIndex = this.currentIndexSubject.value;n    const isPlaying = this.isPlayingSubject.value;n    const wpm = this.wpmSubject.value;n    const totalWords = words.length;n    const progress = totalWords > 0 ? (currentIndex / totalWords) * 100 : 0;n    const currentWord = words[currentIndex] || '';n    const timeRemaining = this.calculateTimeRemaining(totalWords - currentIndex, wpm);n    n    return {n      words,n      currentIndex,n      isPlaying,n      wpm,n      currentWord,n      progress,n      totalWords,n      timeRemainingn    };n  }nn  increaseSpeed(): void {n    const currentWpm = this.wpmSubject.value;n    const newWpm = Math.min(currentWpm + CONSTANTS.WPM_STEP, CONSTANTS.MAX_WPM);n    this.setWpm(newWpm);n  }nn  decreaseSpeed(): void {n    const currentWpm = this.wpmSubject.value;n    const newWpm = Math.max(currentWpm - CONSTANTS.WPM_STEP, CONSTANTS.MIN_WPM);n    this.setWpm(newWpm);n  }nn  hasText(): boolean {n    return this.wordsSubject.value.length > 0;n  }nn  isAtEnd(): boolean {n    const currentIndex = this.currentIndexSubject.value;n    const words = this.wordsSubject.value;n    return currentIndex >= words.length - 1;n  }nn  isAtBeginning(): boolean {n    return this.currentIndexSubject.value === 0;n  }nn  getCurrentWpm(): number {n    return this.wpmSubject.value;n  }nn  private calculateTimeRemaining(totalWords: number, wpm: number): number {n    return totalWords > 0 ? Math.round(totalWords * (60 / wpm)) : 0;n  }nn  setLibraryBook(bookId: string, text: string): void {n    this.setText(text, 'library');n    this.currentBookIdSubject.next(bookId);n  }nn  private startReadingSession(): void {n    this.sessionStartTime = new Date();n  }nn  private endReadingSession(): void {n    if (this.sessionStartTime) {n      const sessionDuration = Date.now() - this.sessionStartTime.getTime();n      const currentIndex = this.currentIndexSubject.value;n      const wpm = this.wpmSubject.value;n      n      this.trackProgress(currentIndex);n      this.saveProgress(currentIndex, sessionDuration, wpm);n      n      this.sessionStartTime = null;n    }n  }nn  private trackProgress(wordIndex: number): void {n    if (wordIndex - this.lastProgressSave >= this.PROGRESS_SAVE_INTERVAL) {n      this.lastProgressSave = wordIndex;n      // Progress tracking logic heren    }n  }nn  private async saveProgress(wordIndex: number, sessionDuration: number, wpm: number): Promise<void> {n    try {n      // Progress saving logic heren      console.log('Progress saved:', { wordIndex, sessionDuration, wpm });n    } catch (error) {n      console.error('Progress save error:', error);n    }n  }nn  getCurrentBookId(): string | null {n    return this.currentBookIdSubject.value;n  }n}